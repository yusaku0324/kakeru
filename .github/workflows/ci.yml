
name: CI

on:
  push:
    branches:
      - main
  pull_request:
  workflow_dispatch:

concurrency:
  group: ci-${{ github.ref }}
  cancel-in-progress: true

permissions:
  contents: read
  id-token: write

jobs:
  api-unit:
    runs-on: ubuntu-latest
    services:
      postgres:
        image: postgres:15
        env:
          POSTGRES_USER: app
          POSTGRES_PASSWORD: app
          POSTGRES_DB: osaka_menesu
        options: >-
          --health-cmd "pg_isready -U app -d osaka_menesu"
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
        ports:
          - 5432:5432
      meilisearch:
        image: getmeili/meilisearch:v1.7
        env:
          MEILI_MASTER_KEY: dev_meili_master_key
          MEILI_ENV: development
          MEILI_NO_ANALYTICS: "true"
        ports:
          - 7700:7700
    env:
      DATABASE_URL: postgresql+asyncpg://app:app@127.0.0.1:5432/osaka_menesu
      MEILI_HOST: http://127.0.0.1:7700
      MEILI_MASTER_KEY: dev_meili_master_key
      ANYIO_BACKEND: asyncio
    defaults:
      run:
        working-directory: osakamenesu/services/api
    steps:
      - uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.11"
          cache: "pip"
          cache-dependency-path: osakamenesu/services/api/requirements-test.txt

      - name: Install dependencies
        run: pip install -r requirements-test.txt

      - name: Wait for Postgres
        env:
          PGPASSWORD: app
        run: |
          for i in {1..60}; do
            if pg_isready -h 127.0.0.1 -p 5432 -U app -d osaka_menesu; then
              exit 0
            fi
            sleep 2
          done
          echo "Postgres did not become ready in time" >&2
          exit 1

      - name: Wait for Meilisearch
        run: |
          for i in {1..30}; do
            if curl -fsS "$MEILI_HOST/health" >/dev/null; then
              exit 0
            fi
            sleep 2
          done
          echo "Meilisearch did not become ready in time" >&2
          exit 1

      - name: Run Alembic migrations
        run: alembic upgrade head

      - name: Run API unit tests (fail under 85% coverage)
        run: |
          export COVERAGE_RCFILE=../../../.coveragerc
          pytest app/tests --cov=app --cov-config="${COVERAGE_RCFILE}" --cov-report=xml
          coverage report --fail-under=85

  web-unit:
    runs-on: ubuntu-latest
    defaults:
      run:
        working-directory: osakamenesu/apps/web
    steps:
      - uses: actions/checkout@v4

      - name: Set up Node.js
        uses: actions/setup-node@v4
        with:
          node-version: "20"
          cache: "npm"
          cache-dependency-path: osakamenesu/apps/web/package-lock.json

      - name: Install dependencies
        run: npm ci

      - name: Run unit tests
        run: npm run test:unit

      - name: Run lint
        run: npm run lint

  admin-e2e:
    runs-on: ubuntu-latest
    needs:
      - api-unit
      - web-unit
    services:
      postgres:
        image: postgres:15
        env:
          POSTGRES_USER: app
          POSTGRES_PASSWORD: app
          POSTGRES_DB: osaka_menesu
        options: >-
          --health-cmd "pg_isready -U app -d osaka_menesu"
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
        ports:
          - 5432:5432
      meilisearch:
        image: getmeili/meilisearch:v1.7
        env:
          MEILI_MASTER_KEY: dev_meili_master_key
          MEILI_ENV: development
          MEILI_NO_ANALYTICS: "true"
        ports:
          - 7700:7700
    env:
      DATABASE_URL: postgresql+asyncpg://app:app@127.0.0.1:5432/osaka_menesu
      MEILI_HOST: http://127.0.0.1:7700
      MEILI_MASTER_KEY: dev_meili_master_key
      ANYIO_BACKEND: asyncio
      NEXT_PUBLIC_SITE_URL: http://127.0.0.1:3000
      ADMIN_API_KEY: ${{ secrets.ADMIN_API_KEY }}
      OSAKAMENESU_ADMIN_API_KEY: ${{ secrets.ADMIN_API_KEY }}
    steps:
      - uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.11"
          cache: "pip"
          cache-dependency-path: osakamenesu/services/api/requirements.txt

      - name: Install API dependencies
        run: pip install -r requirements.txt
        working-directory: osakamenesu/services/api

      - name: Install Node.js
        uses: actions/setup-node@v4
        with:
          node-version: "20"
          cache: "npm"
          cache-dependency-path: osakamenesu/apps/web/package-lock.json

      - name: Install web dependencies
        run: npm ci
        working-directory: osakamenesu/apps/web

      - name: Prepare API server
        run: |
          alembic upgrade head
          uvicorn app.main:app --host 0.0.0.0 --port 8000 &
          echo $! > /tmp/osakamenesu-api.pid
        working-directory: osakamenesu/services/api

      - name: Wait for API health
        run: |
          for i in {1..30}; do
            if curl -fsS http://127.0.0.1:8000/healthz >/dev/null; then
              exit 0
            fi
            sleep 2
          done
          echo "API did not become ready in time" >&2
          exit 1

      - name: Seed admin data
        env:
          ADMIN_BASIC_USER: ${{ secrets.ADMIN_BASIC_USER }}
          ADMIN_BASIC_PASS: ${{ secrets.ADMIN_BASIC_PASS }}
          ADMIN_API_KEY: ${{ secrets.ADMIN_API_KEY }}
        run: npm run e2e:setup
        working-directory: osakamenesu/apps/web

      - name: Run web E2E (non-admin)
        env:
          ADMIN_BASIC_USER: ${{ secrets.ADMIN_BASIC_USER }}
          ADMIN_BASIC_PASS: ${{ secrets.ADMIN_BASIC_PASS }}
          ADMIN_API_KEY: ${{ secrets.ADMIN_API_KEY }}
        run: npm run test:e2e -- --grep-invert "Admin"
        working-directory: osakamenesu/apps/web

      - name: Run admin E2E tests
        env:
          ADMIN_BASIC_USER: ${{ secrets.ADMIN_BASIC_USER }}
          ADMIN_BASIC_PASS: ${{ secrets.ADMIN_BASIC_PASS }}
          ADMIN_API_KEY: ${{ secrets.ADMIN_API_KEY }}
        run: npm run test:e2e -- --grep "Admin"
        working-directory: osakamenesu/apps/web

      - name: Stop API server
        if: always()
        run: |
          if [ -f /tmp/osakamenesu-api.pid ]; then
            kill $(cat /tmp/osakamenesu-api.pid) || true
          fi

  api-integration:
    needs:
      - api-unit
    runs-on: ubuntu-latest
    if: github.event_name != 'pull_request' || github.event.pull_request.head.repo.full_name == github.repository
    defaults:
      run:
        working-directory: osakamenesu
    steps:
      - uses: actions/checkout@v4

      - name: Authenticate to Google Cloud
        uses: google-github-actions/auth@v2
        with:
          credentials_json: ${{ secrets.GCP_SA_KEY }}

      - name: Fetch Meilisearch master key
        id: meili-secret
        uses: google-github-actions/get-secretmanager-secrets@v2
        with:
          secrets: |
            MEILI_MASTER_KEY:projects/${{ secrets.GCP_PROJECT_ID }}/secrets/MEILI_MASTER_KEY/versions/latest

      - name: Run docker-compose integration tests
        env:
          DOCKER_BUILDKIT: 1
          MEILI_MASTER_KEY: ${{ steps.meili-secret.outputs.MEILI_MASTER_KEY }}
        run: docker compose -f docker-compose.test.yml up --build --abort-on-container-exit --exit-code-from osakamenesu-api-test osakamenesu-api-test

      - name: Teardown integration stack
        if: always()
        run: docker compose -f docker-compose.test.yml down -v

  deploy:
    needs:
      - api-unit
      - api-integration
      - web-unit
      - admin-e2e
    if: github.event_name == 'push' && github.ref == 'refs/heads/main'
    runs-on: ubuntu-latest
    env:
      GCP_PROJECT_ID: ${{ secrets.GCP_PROJECT_ID }}
      CLOUD_RUN_API_SERVICE: ${{ secrets.CLOUD_RUN_API_SERVICE }}
      CLOUD_RUN_REGION: ${{ secrets.CLOUD_RUN_REGION }}
      CLOUD_RUN_MEILI_SERVICE: ${{ secrets.CLOUD_RUN_MEILI_SERVICE }}
    permissions:
      contents: read
      id-token: write
    steps:
      - uses: actions/checkout@v4

      - name: Authenticate to Google Cloud
        uses: google-github-actions/auth@v2
        with:
          project_id: ${{ secrets.GCP_PROJECT_ID }}
          credentials_json: ${{ secrets.GCP_SA_KEY }}

      - name: Setup gcloud SDK
        uses: google-github-actions/setup-gcloud@v2

      - name: Configure Docker auth
        run: gcloud auth configure-docker --quiet

      - name: Build API image
        env:
          IMAGE_TAG: ${{ github.sha }}
        run: |
          IMAGE="gcr.io/$GCP_PROJECT_ID/osakamenesu-api:${IMAGE_TAG}"
          echo "IMAGE=${IMAGE}" >> $GITHUB_ENV
          docker build -t "$IMAGE" osakamenesu/services/api

      - name: Push API image
        env:
          IMAGE: ${{ env.IMAGE }}
        run: docker push "$IMAGE"

      - name: Build web image
        env:
          IMAGE_TAG: ${{ github.sha }}
          NEXT_PUBLIC_OSAKAMENESU_API_BASE: ${{ secrets.NEXT_PUBLIC_OSAKAMENESU_API_BASE }}
          NEXT_PUBLIC_API_BASE: ${{ secrets.NEXT_PUBLIC_API_BASE }}
          NEXT_PUBLIC_SITE_URL: ${{ secrets.NEXT_PUBLIC_SITE_URL }}
        run: |
          export NEXT_PUBLIC_OSAKAMENESU_API_BASE="${NEXT_PUBLIC_OSAKAMENESU_API_BASE:-$NEXT_PUBLIC_API_BASE}"
          export NEXT_PUBLIC_SITE_URL="${NEXT_PUBLIC_SITE_URL}"
          WEB_IMAGE="gcr.io/$GCP_PROJECT_ID/osakamenesu-web:${IMAGE_TAG}"
          echo "WEB_IMAGE=${WEB_IMAGE}" >> $GITHUB_ENV
          docker build \
            --build-arg NEXT_PUBLIC_OSAKAMENESU_API_BASE="$NEXT_PUBLIC_OSAKAMENESU_API_BASE" \
            --build-arg NEXT_PUBLIC_SITE_URL="$NEXT_PUBLIC_SITE_URL" \
            -t "$WEB_IMAGE" osakamenesu/apps/web

      - name: Push web image
        env:
          WEB_IMAGE: ${{ env.WEB_IMAGE }}
        run: docker push "$WEB_IMAGE"

      - name: Resolve database connection string
        id: resolve-db-url
        env:
          RAW_DATABASE_URL: ${{ secrets.DATABASE_URL }}
          GCP_PROJECT_ID: ${{ secrets.GCP_PROJECT_ID }}
          CLOUD_RUN_REGION: ${{ secrets.CLOUD_RUN_REGION }}
        run: |
          python3 <<'PY'
          import os
          import sys
          from urllib.parse import urlparse, quote_plus

          raw = os.environ.get("RAW_DATABASE_URL", "").strip()
          if not raw:
              print("::error::DATABASE_URL secret is empty. Please set secrets.DATABASE_URL.", file=sys.stderr)
              sys.exit(1)

          project = os.environ["GCP_PROJECT_ID"]
          region = os.environ["CLOUD_RUN_REGION"]

          parsed = urlparse(raw)
          username = parsed.username or "app"
          password = parsed.password or ""
          database = parsed.path.lstrip("/") or "osaka_menesu"
          scheme = parsed.scheme or "postgresql+asyncpg"

          hostname = (parsed.hostname or "").lower()
          if hostname in {"localhost", "127.0.0.1", ""}:
              encoded = quote_plus(password)
              final = f"{scheme}://{username}:{encoded}@/{database}?host=/cloudsql/{project}:{region}:osakamenesu-pg"
          else:
              final = raw

          print(f"::add-mask::{final}")
          with open(os.environ["GITHUB_OUTPUT"], "a", encoding="utf-8") as fh:
              fh.write(f"database_url={final}\n")
          PY

      - name: Deploy osakamenesu-api to Cloud Run
        env:
          ADMIN_API_KEY: ${{ secrets.ADMIN_API_KEY }}
          DATABASE_URL: ${{ steps.resolve-db-url.outputs.database_url }}
          MEILI_HOST_FALLBACK: ${{ secrets.MEILI_HOST }}
          GCP_PROJECT_ID: ${{ secrets.GCP_PROJECT_ID }}
          SITE_BASE_URL: ${{ secrets.SITE_BASE_URL }}
          MAIL_FROM_ADDRESS: ${{ secrets.MAIL_FROM_ADDRESS }}
          MAIL_PROVIDER_BASE_URL: ${{ secrets.MAIL_PROVIDER_BASE_URL }}
        run: |
          set -euo pipefail
          MEILI_HOST_EFFECTIVE="${MEILI_URL:-}"
          if [ -z "${MEILI_HOST_EFFECTIVE}" ]; then
            MEILI_HOST_EFFECTIVE="${MEILI_HOST_FALLBACK}"
          fi
          if [ -z "${MEILI_HOST_EFFECTIVE}" ]; then
            echo "::error::Meilisearch host is not configured. Set CLOUD_RUN_MEILI_SERVICE or secrets.MEILI_HOST." >&2
            exit 1
          fi
          if ! gcloud secrets versions access latest --project "${GCP_PROJECT_ID}" --secret "MAIL_APIKEY" >/dev/null 2>&1; then
            echo "::error::Secret Manager entry 'MAIL_APIKEY' is not accessible." >&2
            exit 1
          fi
          echo "::add-mask::${MEILI_HOST_EFFECTIVE}"
          ENV_FILE=$(mktemp)
          trap 'rm -f "${ENV_FILE}"' EXIT
          MEILI_HOST_EFFECTIVE="${MEILI_HOST_EFFECTIVE}" ENV_FILE="${ENV_FILE}" python3 <<'PY'
          import json
          import os
          from pathlib import Path

          pairs = {
              "DATABASE_URL": os.environ["DATABASE_URL"],
              "MEILI_HOST": os.environ["MEILI_HOST_EFFECTIVE"],
              "SITE_BASE_URL": os.environ["SITE_BASE_URL"],
              "MAIL_FROM_ADDRESS": os.environ["MAIL_FROM_ADDRESS"],
              "MAIL_PROVIDER_BASE_URL": os.environ["MAIL_PROVIDER_BASE_URL"],
          }

          env_file = Path(os.environ["ENV_FILE"])
          with env_file.open("w", encoding="utf-8") as fh:
              for key, value in pairs.items():
                  fh.write(f"{key}: {json.dumps(value, ensure_ascii=False)}\n")
          PY
          gcloud run services update "${CLOUD_RUN_API_SERVICE}" \
            --region "${CLOUD_RUN_REGION}" \
            --remove-env-vars "MAIL_APIKEY" \
            --remove-secrets "MAIL_APIKEY" \
            --quiet
          gcloud run services update "${CLOUD_RUN_API_SERVICE}" \
            --region "${CLOUD_RUN_REGION}" \
            --add-cloudsql-instances "${GCP_PROJECT_ID}:${CLOUD_RUN_REGION}:osakamenesu-pg" \
            --image "${IMAGE}" \
            --env-vars-file "${ENV_FILE}" \
            --set-secrets "MEILI_MASTER_KEY=MEILI_MASTER_KEY:latest,ADMIN_API_KEY=ADMIN_API_KEY:latest,OSAKAMENESU_ADMIN_API_KEY=OSAKAMENESU_ADMIN_API_KEY:latest,MAIL_APIKEY=MAIL_APIKEY:latest" \
            --quiet

      - name: Deploy osakamenesu-web to Cloud Run
        env:
          CLOUD_RUN_WEB_SERVICE: ${{ secrets.CLOUD_RUN_WEB_SERVICE }}
          CLOUD_RUN_REGION: ${{ secrets.CLOUD_RUN_REGION }}
          ADMIN_API_KEY: ${{ secrets.ADMIN_API_KEY }}
          NEXT_PUBLIC_OSAKAMENESU_API_BASE: ${{ secrets.NEXT_PUBLIC_OSAKAMENESU_API_BASE }}
          NEXT_PUBLIC_API_BASE: ${{ secrets.NEXT_PUBLIC_API_BASE }}
          NEXT_PUBLIC_SITE_URL: ${{ secrets.NEXT_PUBLIC_SITE_URL }}
          OSAKAMENESU_API_INTERNAL_BASE_SECRET: ${{ secrets.OSAKAMENESU_API_INTERNAL_BASE }}
          API_INTERNAL_BASE_SECRET: ${{ secrets.API_INTERNAL_BASE }}
          ADMIN_BASIC_USER: ${{ secrets.ADMIN_BASIC_USER }}
          ADMIN_BASIC_PASS: ${{ secrets.ADMIN_BASIC_PASS }}
          WEB_IMAGE: ${{ env.WEB_IMAGE }}
        run: |
          set -euo pipefail
          if [ -z "${NEXT_PUBLIC_SITE_URL}" ]; then
            echo "::error::NEXT_PUBLIC_SITE_URL secret is required for web deployment." >&2
            exit 1
          fi
          if [ -z "${NEXT_PUBLIC_OSAKAMENESU_API_BASE}" ]; then
            echo "::error::NEXT_PUBLIC_OSAKAMENESU_API_BASE secret is required for web deployment." >&2
            exit 1
          fi

          PUBLIC_BASE="${NEXT_PUBLIC_API_BASE:-${NEXT_PUBLIC_OSAKAMENESU_API_BASE}}"
          INTERNAL_BASE="${OSAKAMENESU_API_INTERNAL_BASE_SECRET:-${NEXT_PUBLIC_OSAKAMENESU_API_BASE}}"
          API_INTERNAL_BASE_EFFECTIVE="${API_INTERNAL_BASE_SECRET:-${INTERNAL_BASE}}"

          ENV_FILE=$(mktemp)
          trap 'rm -f "${ENV_FILE}"' EXIT
          PUBLIC_BASE="${PUBLIC_BASE}" INTERNAL_BASE="${INTERNAL_BASE}" API_INTERNAL_BASE_EFFECTIVE="${API_INTERNAL_BASE_EFFECTIVE}" ENV_FILE="${ENV_FILE}" python3 <<'PY'
          import json
          import os
          from pathlib import Path

          pairs = {
              "ADMIN_API_KEY": os.environ["ADMIN_API_KEY"],
              "NEXT_PUBLIC_SITE_URL": os.environ["NEXT_PUBLIC_SITE_URL"],
              "NEXT_PUBLIC_OSAKAMENESU_API_BASE": os.environ["NEXT_PUBLIC_OSAKAMENESU_API_BASE"],
              "NEXT_PUBLIC_API_BASE": os.environ["PUBLIC_BASE"],
              "ADMIN_BASIC_USER": os.environ["ADMIN_BASIC_USER"],
              "ADMIN_BASIC_PASS": os.environ["ADMIN_BASIC_PASS"],
          }

          internal_base = os.environ.get("INTERNAL_BASE", "")
          if internal_base:
              pairs["OSAKAMENESU_API_INTERNAL_BASE"] = internal_base

          api_internal_base = os.environ.get("API_INTERNAL_BASE_EFFECTIVE", "")
          if api_internal_base:
              pairs["API_INTERNAL_BASE"] = api_internal_base

          env_file = Path(os.environ["ENV_FILE"])
          with env_file.open("w", encoding="utf-8") as fh:
              for key, value in pairs.items():
                  fh.write(f"{key}: {json.dumps(value, ensure_ascii=False)}\n")
          PY
          gcloud run services update "${CLOUD_RUN_WEB_SERVICE}" \
            --region "${CLOUD_RUN_REGION}" \
            --image "${WEB_IMAGE}" \
            --env-vars-file "${ENV_FILE}"

      - name: Seed staging data with sample profiles
        env:
          CLOUD_RUN_API_SERVICE: ${{ secrets.CLOUD_RUN_API_SERVICE }}
          CLOUD_RUN_REGION: ${{ secrets.CLOUD_RUN_REGION }}
          ADMIN_API_KEY: ${{ secrets.ADMIN_API_KEY }}
        run: |
          set -euo pipefail
          SERVICE_URL=$(gcloud run services describe "${CLOUD_RUN_API_SERVICE}" \
            --region "${CLOUD_RUN_REGION}" \
            --format='value(status.url)')
          if [ -z "${SERVICE_URL}" ]; then
            echo "Failed to resolve Cloud Run service URL" >&2
            exit 1
          fi
          echo "::notice::Seeding staging data via ${SERVICE_URL}"
          ID_TOKEN=$(gcloud auth print-identity-token --audiences="${SERVICE_URL}")
          echo "::add-mask::${ID_TOKEN}"
          python3 osakamenesu/services/api/seed_dev.py \
            --api-base "${SERVICE_URL}" \
            --admin-key "${ADMIN_API_KEY}" \
            --id-token "${ID_TOKEN}" \
            --count 10 \
            --today-rate 0.6
