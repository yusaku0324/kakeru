import asyncio
import csv
from pathlib import Path
from playwright.async_api import async_playwright, TimeoutError as PlaywrightTimeoutError
from playwright_stealth import stealth_async

# --- Configuration ---
MARSHMALLOW_POST_URL = "https://marshmallow-qa.com/wiq4442uvh8iawe" # User provided URL (base part)
QUESTIONS_TSV_PATH = Path("questions.tsv")
EXISTING_QUESTIONS_CSV_PATH = Path("message_urls.csv") # CSV generated by generate_message_url_list.py
POST_INTERVAL_SECONDS = 10 # Interval between posts
CUSTOM_USER_AGENT = "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/135.0.0.0 Safari/537.36"

async def submit_question(page, question_text):
    print(f"  Navigating to post page: {MARSHMALLOW_POST_URL}")
    question_area_selector = "#message_content" # 先に定義しておく

    try:
        await page.goto(MARSHMALLOW_POST_URL, wait_until="domcontentloaded", timeout=60000)
        print(f"  DEBUG: page.goto() to {MARSHMALLOW_POST_URL} (domcontentloaded) finished.")
        
        # await page.wait_for_load_state('networkidle', timeout=60000) # コメントアウトまたは削除
        # print("  DEBUG: Networkidle state reached.")

        print(f"  DEBUG: Waiting for crucial element '{question_area_selector}' to be visible...")
        await page.wait_for_selector(question_area_selector, state="visible", timeout=60000) 
        print(f"  DEBUG: Crucial element '{question_area_selector}' is visible.")

    except Exception as e:
        print(f"  DEBUG: ERROR during page.goto or waiting for crucial element: {e}")
        # スクリーンショットは、エラーが起きた時点のページ状態を保存するのに役立ちます
        try:
            await page.screenshot(path="error_page_initial_load.png")
            print("  DEBUG: Screenshot error_page_initial_load.png saved.")
        except Exception as se:
            print(f"  DEBUG: Failed to take screenshot on initial load error: {se}")
        raise
    
    # question_area_selector は既に上で定義済み
    # print(f"  Waiting for question input area: {question_area_selector}") # このprintは重複するので不要かも
    await page.fill(question_area_selector, question_text)
    print(f"  Filled question: \"{question_text[:50]}...\"")
    
    # Click first "おくる" (Send) button
    send_button_1_selector = "button[data-bs-target='#confirm-message']"
    
    print(f"  Waiting for first send button to be visible: {send_button_1_selector}")
    try:
        await page.wait_for_selector(send_button_1_selector, state="visible", timeout=10000)
    except PlaywrightTimeoutError:
        print(f"  Timeout: Button with selector {send_button_1_selector} did not become visible.")
        await page.screenshot(path=f"button_not_visible_{question_text[:10].replace('/ ','_').replace(' ','_')}.png")
        raise

    print(f"  Checking if button exists and is enabled: {send_button_1_selector}")
    button_handle = await page.query_selector(send_button_1_selector)

    if not button_handle:
        print(f"  ERROR: Button with selector {send_button_1_selector} not found by query_selector even after visible wait.")
        await page.screenshot(path=f"button_not_found_by_query_{question_text[:10].replace('/ ','_').replace(' ','_')}.png")
        raise PlaywrightTimeoutError(f"Button {send_button_1_selector} not found by query_selector.")

    enabled_check_count = 0
    while not await button_handle.is_enabled():
        enabled_check_count += 1
        if enabled_check_count > 10: # Max 5 seconds wait (10 * 0.5s)
            print(f"  ERROR: Button {send_button_1_selector} did not become enabled after waiting.")
            await page.screenshot(path=f"button_remained_disabled_{question_text[:10].replace('/ ','_').replace(' ','_')}.png")
            raise PlaywrightTimeoutError(f"Button {send_button_1_selector} did not become enabled.")
        print(f"  Button not enabled yet (attempt {enabled_check_count}), waiting 0.5s...")
        await page.wait_for_timeout(500)
    
    print("  Button is visible and enabled.")
    print(f"  Clicking first send button: {send_button_1_selector}")
    await page.screenshot(path=f"before_click_send1_{question_text[:10].replace('/ ','_').replace(' ','_')}.png")
    await button_handle.click() # Use button_handle.click()
    await page.screenshot(path=f"after_click_send1_{question_text[:10].replace('/ ','_').replace(' ','_')}.png")

    # ▼▼▼ ここから優先度モーダルの処理ブロック全体をコメントアウト ▼▼▼
    # priority_modal_selector = "div.modal.show" 
    # priority_modal_close_button_sub_selector = "button[data-bs-dismiss='modal']" 
    # priority_modal_full_close_selector = f"{priority_modal_selector} {priority_modal_close_button_sub_selector}:visible"
    #
    # try:
    #     print(f"  Checking for VISIBLE priority modal and close button using: {priority_modal_full_close_selector}")
    #     
    #     priority_close_button_locator = page.locator(priority_modal_full_close_selector)
    #     
    #     modal_is_present_and_button_visible = False
    #     try:
    #         await priority_close_button_locator.wait_for(timeout=1500) 
    #         modal_is_present_and_button_visible = await priority_close_button_locator.is_visible()
    #     except PlaywrightTimeoutError:
    #         print("  Priority modal (or its close button) did not become visible quickly.")
    #
    #     if modal_is_present_and_button_visible:
    #         print("  Visible priority modal close button found. Clicking it.")
    #         await priority_close_button_locator.click(timeout=2000)
    #         print("  Priority modal likely closed.")
    #         await page.wait_for_timeout(700) 
    #         # print("DEBUG: Pausing AFTER priority modal close, BEFORE looking for confirmation button.") 
    #         # await page.pause() 
    #     else:
    #         print("  No visible priority modal close button found to click (or modal itself not present/visible).")
    #
    # except Exception as e:
    #     print(f"  Error during priority modal handling (but continuing): {e}")
    #     await page.screenshot(path=f"error_priority_modal_{question_text[:10].replace('/ ','_').replace(' ','_')}.png")
    #     pass 
    # ▲▲▲ ここまでコメントアウト ▲▲▲

    # Click second "おくる" (Confirm) button
    
    # 提案セレクタ 1 (最も推奨)
    send_button_2_selector = "button.btn.btn-primary[form='new_message'][data-character-counter-target='submit'][type='submit']"
    
    try:
        print(f"  Waiting for VISIBLE second send button (confirmation): {send_button_2_selector}")
        await page.wait_for_selector(send_button_2_selector, state="visible", timeout=15000) 
        print("  Visible second send button found.")

        confirm_button_handle = await page.query_selector(send_button_2_selector)
        if confirm_button_handle:
            print("  Attempting to click the confirmation button...")
            await confirm_button_handle.click()
            print("  Second send button clicked (question likely submitted).")
        else:
            print(f"  ERROR: Could not get ElementHandle for selector: {send_button_2_selector} even after wait_for_selector.")
            raise Exception(f"Could not get ElementHandle for selector: {send_button_2_selector}")

        print("  Waiting for submission to process and success message...")
        
        success_message_selector = "div.modal-title:has-text('メッセージをおくりました！')"
        try:
            await page.wait_for_selector(success_message_selector, timeout=10000) # 10秒待機
            print(f"  Submission success message found: '{await page.locator(success_message_selector).text_content()}'")
            await page.wait_for_timeout(1000) # メッセージ確認後、少し待つ

        except PlaywrightTimeoutError:
            print(f"  Submission success message ('{success_message_selector}') not found after 10 seconds. Saving screenshot.")
            await page.screenshot(path=f"post_submission_no_success_msg_{question_text[:10].replace('/ ','_').replace(' ','_')}.png")
            print("  WARN: Proceeding to next question despite not finding explicit success message.")

        current_url = page.url
        if MARSHMALLOW_POST_URL in current_url: 
            print(f"  Still on the posting page (URL: {current_url}). This is expected if success message appeared.")
        else:
            print(f"  Page redirected or changed. Current URL: {current_url}.")
            
    except PlaywrightTimeoutError:
        print(f"  Timeout: Second send button (confirmation) with selector '{send_button_2_selector}' not found or not visible.")
        await page.screenshot(path=f"post_confirmation_button_error_{question_text[:10].replace('/ ','_').replace(' ','_')}.png")
        # raise 
    except Exception as e:
        print(f"  ERROR clicking second send button or during post-submission wait: {e}")
        await page.screenshot(path=f"post_confirmation_generic_error_{question_text[:10].replace('/ ','_').replace(' ','_')}.png")
        # raise

async def main():
    # 1. Load existing questions from message_urls.csv
    existing_questions = set()
    if EXISTING_QUESTIONS_CSV_PATH.exists():
        with open(EXISTING_QUESTIONS_CSV_PATH, mode='r', encoding='utf-8') as csvfile:
            reader = csv.DictReader(csvfile)
            for row in reader:
                if row.get("question"):
                    existing_questions.add(row["question"].strip())
        print(f"Loaded {len(existing_questions)} existing questions from {EXISTING_QUESTIONS_CSV_PATH}")
    else:
        print(f"Warning: {EXISTING_QUESTIONS_CSV_PATH} not found. Assuming no questions have been posted yet.")

    # 2. Load all questions from questions.tsv
    all_questions_to_post = []
    if not QUESTIONS_TSV_PATH.exists():
        print(f"Error: {QUESTIONS_TSV_PATH} not found. Cannot proceed.")
        return
    with open(QUESTIONS_TSV_PATH, mode='r', encoding='utf-8') as tsvfile:
        reader = csv.reader(tsvfile, delimiter='\t')
        for row in reader:
            if row and row[0].strip(): # Ensure row and first column are not empty
                all_questions_to_post.append(row[0].strip())
    print(f"Loaded {len(all_questions_to_post)} total questions from {QUESTIONS_TSV_PATH}")

    # 3. Determine missing questions
    missing_questions = [
        q for q in all_questions_to_post if q not in existing_questions
    ]

    if not missing_questions:
        print("No missing questions to post. All questions from TSV are already in the CSV or TSV is empty.")
        return
    
    print(f"Found {len(missing_questions)} questions to post.")
    for i, q_text in enumerate(missing_questions):
        print(f"  {i+1}. {q_text[:70]}...")

    async with async_playwright() as p:
        browser = await p.chromium.launch(headless=False)
        # Using a new context for each question to ensure a clean state (no cookies from previous anonymous posts)
        # However, for rapid anonymous posting, one context might be fine too.
        # Let's use one context for this session to be a bit more efficient.
        context = await browser.new_context(user_agent=CUSTOM_USER_AGENT) # No storage_state for anonymous
        page = await context.new_page()
        # await stealth_async(page) # Temporarily commented out for debugging PWDEBUG issue
        print("DEBUG: Page object created, stealth (if enabled) would have been applied.")

        for i, question_to_post in enumerate(missing_questions):
            print(f"\nPosting question {i+1}/{len(missing_questions)}: '{question_to_post[:50]}...'")
            try:
                await submit_question(page, question_to_post)
                print(f"  Successfully submitted (or attempted to submit) question.")
            except Exception as e:
                print(f"  ERROR posting question '{question_to_post[:50]}...': {e}")
                await page.screenshot(path=f"error_posting_question_{i+1}.png")
            
            if i < len(missing_questions) - 1:
                print(f"  Waiting for {POST_INTERVAL_SECONDS} seconds before next post...")
                await asyncio.sleep(POST_INTERVAL_SECONDS)
        
        print("\nAll missing questions have been processed.")
        await context.close() # Close context after all posts in the session
        await browser.close()

if __name__ == "__main__":
    asyncio.run(main()) 